---
alwaysApply: true
description: Thread-safe global registry pattern for managing shared objects by native handles
---

# Global Registry Pattern Rules

The [GlobalRegistry](mdc:src/global_registry.h) template provides a thread-safe singleton registry for mapping native platform handles (void*) to C++ wrapper objects (shared_ptr). This is essential for converting platform callbacks back to C++ objects.

## Purpose

The GlobalRegistry solves a key problem in platform abstraction:

**Problem**: Platform callbacks provide native handles, but we need C++ wrapper objects.

```cpp
// Platform callback gives us HWND, NSWindow*, or GtkWidget*
void OnWindowEvent(void* native_handle) {
    // How do we get from void* to std::shared_ptr<Window>?
}
```

**Solution**: Register C++ objects by their native handle when created.

```cpp
auto window = std::make_shared<Window>(native_handle);
GlobalRegistry<Window>().Register(native_handle, window);

// Later in platform callback:
void OnWindowEvent(void* native_handle) {
    auto window = GlobalRegistry<Window>().Get(native_handle);
    if (window) {
        // Use window wrapper
    }
}
```

## Registry API

### Template Structure ([global_registry.h](mdc:src/global_registry.h))

```cpp
namespace nativeapi {

template <typename T>
class Registry {
public:
    using Key = void*;
    using Ptr = std::shared_ptr<T>;

    static Registry& GetInstance();

    // Register an object with a key
    bool Register(Key key, Ptr object);

    // Unregister an object by key
    bool Unregister(Key key);

    // Retrieve an object by key
    Ptr Get(Key key) const;

    // Check if key exists
    bool Contains(Key key) const;

    // Clear all entries
    void Clear();

    // Get snapshot of all entries
    std::unordered_map<Key, Ptr> GetSnapshot() const;

private:
    Registry() = default;
    mutable std::mutex mutex_;
    std::unordered_map<Key, Ptr> registry_;
};

// Convenience function
template <typename T>
inline Registry<T>& GlobalRegistry() {
    return Registry<T>::GetInstance();
}

}  // namespace nativeapi
```

## Usage Pattern

### 1. Registration on Object Creation

When creating a wrapper object, register it by its native handle:

```cpp
// Windows example - window creation
class WindowManager::Impl {
public:
    std::shared_ptr<Window> CreatePlatformWindow(const WindowOptions& options) {
        // Create native window
        HWND hwnd = CreateWindowEx(...);
        if (!hwnd) return nullptr;

        // Create wrapper
        auto window = std::make_shared<Window>(static_cast<void*>(hwnd));

        // Register in global registry
        GlobalRegistry<Window>().Register(static_cast<void*>(hwnd), window);

        return window;
    }
};
```

```objc
// macOS example - window creation
class WindowManager::Impl {
public:
    std::shared_ptr<Window> CreatePlatformWindow(const WindowOptions& options) {
        // Create native window
        NSWindow* nswindow = [[NSWindow alloc] init...];
        if (!nswindow) return nullptr;

        // Create wrapper
        auto window = std::make_shared<Window>(static_cast<void*>(nswindow));

        // Register in global registry
        GlobalRegistry<Window>().Register(static_cast<void*>(nswindow), window);

        return window;
    }
};
```

### 2. Lookup in Platform Callbacks

When platform code calls back with native handles, look up the wrapper:

#### Windows Message Handler

```cpp
// Window procedure callback
LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) {
    // Look up Window wrapper from native handle
    auto window = GlobalRegistry<Window>().Get(static_cast<void*>(hwnd));

    if (!window) {
        return DefWindowProc(hwnd, msg, wp, lp);
    }

    // Handle message using wrapper
    switch (msg) {
        case WM_SIZE:
            // Emit WindowResizedEvent
            break;
        case WM_MOVE:
            // Emit WindowMovedEvent
            break;
    }

    return DefWindowProc(hwnd, msg, wp, lp);
}
```

#### macOS Notification Handler

```objc
@implementation WindowDelegate

- (void)windowDidMove:(NSNotification*)notification {
    NSWindow* nswindow = [notification object];

    // Look up Window wrapper from native handle
    auto window = nativeapi::GlobalRegistry<nativeapi::Window>()
        .Get(static_cast<void*>(nswindow));

    if (window) {
        // Emit WindowMovedEvent using wrapper
        NSRect frame = [nswindow frame];
        // ...
    }
}

@end
```

#### Linux Signal Handler

```cpp
// GTK signal callback
static void OnWindowStateChanged(GtkWidget* widget,
                                 GdkEventWindowState* event,
                                 gpointer user_data) {
    // Look up Window wrapper from native handle
    auto window = GlobalRegistry<Window>().Get(static_cast<void*>(widget));

    if (window) {
        // Emit appropriate event using wrapper
        if (event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) {
            // Emit WindowMaximizedEvent
        }
    }
}
```

### 3. Unregistration on Object Destruction

When destroying a wrapper, unregister it from the global registry:

```cpp
class Window {
public:
    ~Window() {
        // Get native handle before pimpl_ is destroyed
        void* native = GetNativeObject();

        if (native) {
            // Unregister from global registry
            GlobalRegistry<Window>().Unregister(native);
        }

        // pimpl_ destructor will clean up native object
    }

private:
    class Impl;
    std::unique_ptr<Impl> pimpl_;
};
```

Or unregister when manager destroys object:

```cpp
bool WindowManager::Destroy(WindowId id) {
    auto it = windows_.find(id);
    if (it == windows_.end()) {
        return false;
    }

    auto window = it->second;

    // Unregister from global registry
    void* native = window->GetNativeObject();
    if (native) {
        GlobalRegistry<Window>().Unregister(native);
    }

    // Remove from local registry
    windows_.erase(it);

    // Emit event
    Emit<WindowClosedEvent>(id);

    return true;
}
```

## Common Use Cases

### Use Case 1: Menu Click Events

Menus are particularly reliant on GlobalRegistry:

```cpp
// Register menu when created
auto menu = std::make_shared<Menu>();
void* native_menu = menu->GetNativeObject();
GlobalRegistry<Menu>().Register(native_menu, menu);

// Register menu items
auto item = std::make_shared<MenuItem>("Open");
menu->AddItem(item);
void* native_item = item->GetNativeObject();
GlobalRegistry<MenuItem>().Register(native_item, item);
```

Platform callback for menu item click:

```cpp
// Windows
void OnMenuCommand(HMENU hmenu, UINT item_id) {
    // Look up by some identifier or stored mapping
    auto item = GlobalRegistry<MenuItem>().Get(/* native handle */);
    if (item) {
        item->Trigger();  // Emit MenuItemClickedEvent
    }
}

// macOS
- (void)menuItemClicked:(id)sender {
    NSMenuItem* nsitem = (NSMenuItem*)sender;

    auto item = nativeapi::GlobalRegistry<nativeapi::MenuItem>()
        .Get(static_cast<void*>(nsitem));

    if (item) {
        item->Trigger();
    }
}

// Linux
static void OnMenuItemActivated(GtkMenuItem* menu_item, gpointer user_data) {
    auto item = nativeapi::GlobalRegistry<nativeapi::MenuItem>()
        .Get(static_cast<void*>(menu_item));

    if (item) {
        item->Trigger();
    }
}
```

### Use Case 2: Wrapping Existing Native Objects

When wrapping an existing platform object:

```cpp
// User provides native window handle to wrap
auto window = std::make_shared<Window>(existing_hwnd);

// Register it so platform callbacks work
GlobalRegistry<Window>().Register(existing_hwnd, window);
```

### Use Case 3: Bulk Operations

Get all registered objects:

```cpp
// Get snapshot of all windows
auto snapshot = GlobalRegistry<Window>().GetSnapshot();

for (const auto& [native, window] : snapshot) {
    // Process each window
    std::cout << "Window: " << window->GetTitle() << std::endl;
}
```

## Thread Safety

The GlobalRegistry is fully thread-safe:

```cpp
// Thread 1: Register
std::thread t1([&]() {
    GlobalRegistry<Window>().Register(handle1, window1);
});

// Thread 2: Lookup
std::thread t2([&]() {
    auto window = GlobalRegistry<Window>().Get(handle1);
});

// Thread 3: Unregister
std::thread t3([&]() {
    GlobalRegistry<Window>().Unregister(handle2);
});

// All operations are safe - internal mutex protects access
```

## Memory Management

### Registry Holds Shared Pointers

The registry stores `std::shared_ptr<T>`, which means:

1. **Reference Counting** - Registry holds a reference, keeping object alive
2. **Automatic Cleanup** - When unregistered and last shared_ptr released, object is destroyed
3. **Shared Ownership** - Multiple places can hold references to same object

### Lifetime Pattern

```cpp
// Create and register
auto window = std::make_shared<Window>(native);  // ref count = 1
GlobalRegistry<Window>().Register(native, window); // ref count = 2

// Manager also holds reference
manager.windows_[id] = window;  // ref count = 3

// Unregister from global registry
GlobalRegistry<Window>().Unregister(native);  // ref count = 2

// Remove from manager
manager.windows_.erase(id);  // ref count = 1

// User's shared_ptr still valid
window->Show();  // OK, ref count still 1

// When last reference goes out of scope
window = nullptr;  // ref count = 0, object destroyed
```

## Best Practices

### 1. Register Immediately After Creation

```cpp
// Good - register right after creation
auto window = std::make_shared<Window>(native);
GlobalRegistry<Window>().Register(native, window);

// Bad - delay between creation and registration
auto window = std::make_shared<Window>(native);
// ... other code ...
GlobalRegistry<Window>().Register(native, window);  // Callbacks may miss this
```

### 2. Unregister Before Native Handle Becomes Invalid

```cpp
// Good - unregister in destructor
Window::~Window() {
    void* native = GetNativeObject();
    if (native) {
        GlobalRegistry<Window>().Unregister(native);
    }
}

// Bad - native handle already destroyed
Window::~Window() {
    // pimpl_ destroyed here, native handle now invalid
}
~Window() {
    GlobalRegistry<Window>().Unregister(/* dangling pointer */);
}
```

### 3. Check for Null Before Using Retrieved Objects

```cpp
// Good - check for null
auto window = GlobalRegistry<Window>().Get(native);
if (window) {
    window->Show();
}

// Bad - assume it exists
auto window = GlobalRegistry<Window>().Get(native);
window->Show();  // May crash if null
```

### 4. Don't Assume Registration Succeeded

```cpp
// Registration can fail if key already exists
bool success = GlobalRegistry<Window>().Register(native, window);
if (!success) {
    // Handle error - native handle already registered
    // This may indicate a bug or handle reuse
}
```

## Type Safety

Each type has its own registry:

```cpp
// Separate registries for different types
GlobalRegistry<Window>().Register(handle1, window);
GlobalRegistry<Menu>().Register(handle2, menu);
GlobalRegistry<MenuItem>().Register(handle3, item);

// Type-safe retrieval
auto window = GlobalRegistry<Window>().Get(handle1);  // Returns shared_ptr<Window>
auto menu = GlobalRegistry<Menu>().Get(handle2);      // Returns shared_ptr<Menu>
```

## Singleton Lifetime

The registry uses heap allocation to avoid static destruction order issues:

```cpp
template <typename T>
Registry<T>& Registry<T>::GetInstance() {
    static auto* instance = new Registry();  // Never destroyed
    return *instance;
}
```

This ensures the registry remains valid for the entire program lifetime, including during static destruction.

## Debugging

### Check if Object is Registered

```cpp
void* native = window->GetNativeObject();
if (GlobalRegistry<Window>().Contains(native)) {
    std::cout << "Window is registered" << std::endl;
} else {
    std::cout << "Window NOT registered - bug?" << std::endl;
}
```

### Print All Registered Objects

```cpp
auto snapshot = GlobalRegistry<Window>().GetSnapshot();
std::cout << "Registered windows: " << snapshot.size() << std::endl;

for (const auto& [native, window] : snapshot) {
    std::cout << "  - " << window->GetTitle()
              << " (native: " << native << ")" << std::endl;
}
```

## Common Pitfalls

### ❌ Don't Forget to Unregister

```cpp
// Bad - memory leak
{
    auto window = std::make_shared<Window>(native);
    GlobalRegistry<Window>().Register(native, window);
    // window goes out of scope, but registry still holds reference
    // Window never destroyed!
}

// Good - unregister when done
{
    auto window = std::make_shared<Window>(native);
    GlobalRegistry<Window>().Register(native, window);
    // ...
    GlobalRegistry<Window>().Unregister(native);
    // Now window can be destroyed when it goes out of scope
}
```

### ❌ Don't Register with Wrong Handle

```cpp
// Bad - registering with wrong native handle
auto window = std::make_shared<Window>(native1);
GlobalRegistry<Window>().Register(native2, window);  // Wrong!

// Platform callbacks with native1 won't find the window
```

### ❌ Don't Assume Handle Uniqueness Across Types

```cpp
// Native handles might be reused
GlobalRegistry<Window>().Register(handle, window);
// Later, handle might be reused for a menu
GlobalRegistry<Menu>().Register(handle, menu);  // Different registry, OK

// But don't register same handle twice in same registry
GlobalRegistry<Window>().Register(handle, window1);
GlobalRegistry<Window>().Register(handle, window2);  // Fails!
```

## Related Topics

- See [Platform Implementation Rules](mdc:.cursor/rules/platform-implementation.mdc) for callback patterns
- See [Singleton Managers Rules](mdc:.cursor/rules/singleton-managers.mdc) for manager integration
- See [Native Object Provider Rules](mdc:.cursor/rules/native-object-provider.mdc) for handle access
