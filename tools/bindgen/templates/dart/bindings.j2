// Generated by bindgen. Do not edit.

import 'dart:ffi';
import 'package:ffi/ffi.dart';

{% macro ffi_type(t) -%}
{%- if t.kind == 'pointer' -%}
Pointer<{{ ffi_type(t.to) }}>
{%- elif t.kind == 'cstring' -%}
Pointer<Utf8>
{%- elif t.kind == 'struct' -%}
{{ t.name }}
{%- elif t.kind == 'enum' -%}
Int32
{%- elif t.kind == 'alias' -%}
{{ mapping.types.get(t.name, 'IntPtr') }}
{%- else -%}
{{ mapping.types.get(t.kind, 'Void') }}
{%- endif -%}
{%- endmacro %}

{% macro dart_type(t) -%}
{{ ffi_type(t) }}
{%- endmacro %}

{% for s in types %}
class {{ s.name }} extends Struct {
{% for f in s.fields %}
{% set ann = mapping.annotations.get(f.type.kind) %}
{% if ann %}
  @{{ ann }}()
{% endif %}
  external {{ dart_type(f.type) }} {{ f.name }};
{% endfor %}
}
{% endfor %}

class Bindings {
  Bindings(this._lib);

  final DynamicLibrary _lib;

{% for fn in functions %}
  late final {{ dart_type(fn.return_type) }} Function({% for p in fn.params %}{{ dart_type(p.type) }}{{ ", " if not loop.last }}{% endfor %})
      {{ fn.name }} = _lib
          .lookup<NativeFunction<{{ ffi_type(fn.return_type) }} Function({% for p in fn.params %}{{ ffi_type(p.type) }}{{ ", " if not loop.last }}{% endfor %})>>('{{ fn.name }}')
          .asFunction();

{% endfor %}
}
